diff --git a/blivet/tasks/availability.py b/blivet/tasks/availability.py
index 7811be1..9e94cb2 100644
--- a/blivet/tasks/availability.py
+++ b/blivet/tasks/availability.py
@@ -19,9 +19,10 @@
 #
 # Red Hat Author(s): Anne Mulhern <amulhern@redhat.com>
 
+import re
+import os
 import abc
 from distutils.version import LooseVersion
-import hawkey
 
 from six import add_metaclass
 
@@ -37,6 +38,8 @@ import logging
 log = logging.getLogger("blivet")
 
 CACHE_AVAILABILITY = True
+NIX_STOREPATH_RE = re.compile('^/nix/store/[a-z0-9]+-([^/]+?)-([^/]*)/.*$',
+                              re.IGNORECASE)
 
 
 class ExternalResource(object):
@@ -153,22 +156,22 @@ class PackageMethod(Method):
             :rtype: LooseVersion
             :raises AvailabilityError: on failure to obtain package version
         """
-        sack = hawkey.Sack()
-
-        try:
-            sack.load_system_repo()
-        except IOError as e:
-            # hawkey has been observed allowing an IOError to propagate to
-            # caller with message "Failed calculating RPMDB checksum."
-            # See: https://bugzilla.redhat.com/show_bug.cgi?id=1223914
-            raise AvailabilityError("Could not determine package version for %s: %s" % (self.package.package_name, e))
-
-        query = hawkey.Query(sack).filter(name=self.package.package_name, latest=True)
-        packages = query.run()
-        if len(packages) != 1:
-            raise AvailabilityError("Could not determine package version for %s: unable to obtain package information from repo" % self.package.package_name)
-
-        return LooseVersion(packages[0].version)
+        bin_searchpath = os.getenv('PATH')
+        if bin_searchpath is None:
+            raise AvailabilityError("Could not determine package version for %s" % self.package.package_name)
+
+        for store_path in set(filter(
+            lambda p: p.startswith('/nix/store/'),
+            [os.path.realpath(p) for p in bin_searchpath.split(':')]
+        )):
+            match = NIX_STOREPATH_RE.match(store_path)
+            if match is None:
+                continue
+            if match.group(1) != self.package.package_name:
+                continue
+            return LooseVersion(match.group(2))
+
+        raise AvailabilityError("Could not determine package version for %s" % self.package.package_name)
 
     def availability_errors(self, resource):
         if self._availability_errors is not None and CACHE_AVAILABILITY:
