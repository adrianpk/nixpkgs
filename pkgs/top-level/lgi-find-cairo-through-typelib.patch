Reorder some code so that the cairo-gobject library is used before this tries to
dlopen("libcairo.so.2"). Since cairo-gobject depends (RT_DEPEND) on cairo, this
causes cairo to be used and so the missing search path for the dlopen() call is
not a problem.

diff --git a/lgi/override/cairo.lua b/lgi/override/cairo.lua
index ca8193f..019239b 100644
--- a/lgi/override/cairo.lua
+++ b/lgi/override/cairo.lua
@@ -20,18 +20,8 @@ local record = require 'lgi.record'
 local enum = require 'lgi.enum'
 local ti = ffi.types
 
-cairo._module = core.module('cairo', 2)
 local module_gobject = core.gi.cairo.resolve
 
--- Versioning support.
-function cairo.version_encode(major, minor, micro)
-   return 10000 * major + 100 * minor + micro
-end
-cairo.version = core.callable.new {
-   addr = cairo._module.cairo_version, ret = ti.int } ()
-cairo.version_string = core.callable.new {
-   addr = cairo._module.cairo_version_string, ret = ti.utf8 } ()
-
 -- Load some constants.
 cairo._constant = {
    MIME_TYPE_JP2 = 'image/jp2',
@@ -58,6 +48,18 @@ for _, name in pairs {
    end
 end
 
+-- Load libcairo.so directly; this has to happen after the typelib was used
+cairo._module = core.module('cairo', 2)
+
+-- Versioning support.
+function cairo.version_encode(major, minor, micro)
+   return 10000 * major + 100 * minor + micro
+end
+cairo.version = core.callable.new {
+   addr = cairo._module.cairo_version, ret = ti.int } ()
+cairo.version_string = core.callable.new {
+   addr = cairo._module.cairo_version_string, ret = ti.utf8 } ()
+
 -- Load definitions of all boxed records.
 cairo._struct = cairo._struct or {}
 for index, struct in pairs {
